#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Sort / Class / Duplicate checker & fixer

根据 requirements.md: 对图片文件名中的 class 与 duplicate 序号进行检查与（可选）自动纠正。

文件名格式变体：
  tag_time-tag_train/val_class_duplicate.png
  time_hash-tag_train/val_class_duplicate.png
核心只关心末尾结构： *_train|val_CLASS_DUP.png  (扩展名不限 png/jpg/jpeg/webp)

Rules:
 1. class 应从 1 开始连续。
    - 若存在跳号：后续所有 class 前移补齐（重映射）
 2. duplicate 在同一个 class 内应从 1 开始连续。
    - 缺失：后续 duplicate 依次前移补齐（重映射）
    - 重复：仅报告，不自动修复（需用户人工确认原因）。

Dry-run 默认；需 --apply 才会真的重命名。

Author: autogenerated by assistant
"""
from __future__ import annotations
import argparse
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Dict, Tuple, Iterable, Optional

SUPPORTED_EXT = {'.png', '.jpg', '.jpeg', '.webp'}
# 末尾捕获: _train|val_CLASS_DUP(.ext)
# 我们允许前缀任意, 用惰性匹配直到最后两个下划线数值段
PATTERN = re.compile(r"^(?P<prefix>.*?)(?:_)?(?P<phase>train|val)_(?P<class>\d+)_(?P<dup>\d+)(?P<ext>\.[A-Za-z0-9]+)$")

@dataclass
class FileInfo:
    path: Path
    phase: str
    cls: int
    dup: int
    prefix: str
    ext: str
    original_name: str = field(init=False)

    def __post_init__(self):
        self.original_name = self.path.name

    def build_name(self, cls: Optional[int] = None, dup: Optional[int] = None) -> str:
        new_cls = cls if cls is not None else self.cls
        new_dup = dup if dup is not None else self.dup
        return f"{self.prefix}_{self.phase}_{new_cls}_{new_dup}{self.ext}" if self.prefix else f"{self.phase}_{new_cls}_{new_dup}{self.ext}"

    def __hash__(self) -> int:  # allow use in sets
        return hash(self.path)


def parse_filename(p: Path) -> Optional[FileInfo]:
    m = PATTERN.match(p.name)
    if not m:
        return None
    ext = m.group('ext')
    if ext.lower() not in SUPPORTED_EXT:
        return None
    return FileInfo(
        path=p,
        phase=m.group('phase'),
        cls=int(m.group('class')),
        dup=int(m.group('dup')),
        prefix=m.group('prefix').rstrip('_'),
        ext=ext
    )

@dataclass
class ClassResult:
    old_to_new: Dict[int, int]
    had_gap: bool

@dataclass
class DuplicateIssue:
    cls: int
    duplicate_value: int
    file_names: List[str]
    # 添加: 暂存选择的解决方案(可选)
    # solution_type: 'rename-dup' | 'move-class' | None
    # not persisted; handled in interactive flow

@dataclass
class DuplicateReindex:
    cls: int
    mapping: Dict[int, int]  # old dup -> new dup

@dataclass
class PlanEntry:
    file: FileInfo
    new_name: str

@dataclass
class Report:
    total_files: int
    parsed_files: int
    unparsable: List[str]
    class_result: ClassResult
    duplicate_conflicts: List[DuplicateIssue]
    duplicate_reindex: List[DuplicateReindex]
    rename_plan: List[PlanEntry]

# ---------------- core logic -----------------

def load_files(directory: Path) -> Tuple[List[FileInfo], List[str]]:
    parsed: List[FileInfo] = []
    unparsable: List[str] = []
    for p in sorted(directory.iterdir()):
        if p.is_file():
            fi = parse_filename(p)
            if fi:
                parsed.append(fi)
            else:
                unparsable.append(p.name)
    return parsed, unparsable


def build_class_mapping(files: List[FileInfo]) -> ClassResult:
    # 取现有 class 去重排序
    classes = sorted({f.cls for f in files})
    had_gap = classes != list(range(1, len(classes) + 1))
    mapping = {old: idx + 1 for idx, old in enumerate(classes)}
    return ClassResult(old_to_new=mapping, had_gap=had_gap)


def apply_class_mapping(files: List[FileInfo], class_result: ClassResult) -> None:
    for f in files:
        f.cls = class_result.old_to_new[f.cls]


def analyze_duplicates(files: List[FileInfo]) -> Tuple[List[DuplicateIssue], List[DuplicateReindex]]:
    # 按 class 分组
    by_class: Dict[int, List[FileInfo]] = {}
    for f in files:
        by_class.setdefault(f.cls, []).append(f)

    conflicts: List[DuplicateIssue] = []
    reindexes: List[DuplicateReindex] = []

    for cls, flist in sorted(by_class.items()):
        # 按 dup 升序
        flist_sorted = sorted(flist, key=lambda x: x.dup)
        dups_seen: Dict[int, List[str]] = {}
        for fi in flist_sorted:
            dups_seen.setdefault(fi.dup, []).append(fi.original_name)
        # 检测重复（出现次数 >1）
        dup_conflicts = {dup: names for dup, names in dups_seen.items() if len(names) > 1}
        if dup_conflicts:
            for dup, names in sorted(dup_conflicts.items()):
                conflicts.append(DuplicateIssue(cls=cls, duplicate_value=dup, file_names=names))
            # 有冲突则不做自动 reindex
            continue
        # 没有冲突则检查连续性
        existing = sorted(dups_seen.keys())
        target = list(range(1, len(existing) + 1))
        if existing != target:
            mapping = {old: i + 1 for i, old in enumerate(existing)}
            reindexes.append(DuplicateReindex(cls=cls, mapping=mapping))
    return conflicts, reindexes


def interactive_resolve_duplicate_conflicts(conflicts: List[DuplicateIssue], files: List[FileInfo]) -> None:
    """交互式处理 duplicate 冲突。

    对每个冲突 (class, duplicate_value) 提供三种策略：
      r = 重排当前 class 下所有文件的 duplicate (按文件名排序重新编号 1..n)
      m = 将选定的一个或多个冲突文件移动到一个新 class (new_class = 当前最大 class + 1) 并从1开始编号
      s = 跳过该冲突，不做修改

    可对同一个冲突多次执行 m（移动部分文件后剩余继续处理），直到冲突消除或选择跳过。
    注意：此函数直接修改传入的 FileInfo 对象 (cls / dup)。
    """
    if not conflicts:
        return
    print("\n== 进入交互式 duplicate 冲突处理 ==")

    name_to_fi: Dict[str, FileInfo] = {f.original_name: f for f in files}

    def current_max_class() -> int:
        vals = [f.cls for f in files]
        return max(vals) if vals else 0

    for issue in conflicts:
        # 循环直到该冲突被解决或用户跳过
        while True:
            remaining_files = [fn for fn in issue.file_names if fn in name_to_fi]
            # 过滤出仍然在原 class 且 dup 未改变的文件（目标是继续观察是否冲突还存在）
            active_conflict_files = []
            for fn in remaining_files:
                fi = name_to_fi[fn]
                if fi.cls == issue.cls and fi.dup == issue.duplicate_value:
                    active_conflict_files.append(fn)

            if len(active_conflict_files) <= 1:
                print(f"冲突 class {issue.cls} dup {issue.duplicate_value} 已解除。")
                break

            print(f"\n冲突: class {issue.cls} duplicate={issue.duplicate_value}")
            for idx, fname in enumerate(active_conflict_files):
                fi = name_to_fi.get(fname)
                abs_path = str(fi.path.resolve()) if fi else "(未知路径)"
                print(f"  [{idx}] {fname}")
                print(f"      绝对路径: {abs_path}")
            print("操作: (r)重排本class  (m)移动所选文件到新class  (s)跳过")
            choice = input("请输入操作字母: ").strip().lower()

            if choice == 's':
                print("跳过该冲突。")
                break
            elif choice == 'r':
                class_files = [f for f in files if f.cls == issue.cls]
                class_files_sorted = sorted(class_files, key=lambda x: x.original_name)
                for i, fi in enumerate(class_files_sorted, start=1):
                    fi.dup = i
                print(f"已重排 class {issue.cls} 的 duplicate → 1..{len(class_files_sorted)}")
                break  # 该冲突自然消失
            elif choice == 'm':
                sel = input("输入要移动文件的序号(可逗号分隔): ").strip()
                if not sel:
                    print("未输入序号。")
                    continue
                try:
                    indices = [int(x) for x in sel.split(',') if x.strip() != '']
                except ValueError:
                    print("格式错误。")
                    continue
                chosen: List[FileInfo] = []
                for i in indices:
                    if 0 <= i < len(active_conflict_files):
                        fi = name_to_fi[active_conflict_files[i]]
                        chosen.append(fi)
                    else:
                        print(f"索引 {i} 超出范围，忽略。")
                if not chosen:
                    print("没有有效文件。")
                    continue
                new_cls = current_max_class() + 1
                # 放入同一个新 class，dup 按选择顺序 1..n
                for idx, fi in enumerate(chosen, start=1):
                    fi.cls = new_cls
                    fi.dup = idx
                print(f"已移动 {len(chosen)} 个文件到新 class {new_cls} (dup 从1开始)。")
                # 循环继续，直到冲突解除或用户跳过
                continue
            else:
                print("无效输入，请重新选择。")
                continue

    print("== 交互处理结束 ==\n")


def build_rename_plan(files: List[FileInfo], dup_reindexes: List[DuplicateReindex]) -> List[PlanEntry]:
    # 建立 dup 映射表 (class, old_dup) -> new_dup
    dup_map: Dict[Tuple[int, int], int] = {}
    for r in dup_reindexes:
        for old, new in r.mapping.items():
            dup_map[(r.cls, old)] = new

    plan: List[PlanEntry] = []
    for f in files:
        new_dup = dup_map.get((f.cls, f.dup), f.dup)
        new_name = f.build_name(cls=f.cls, dup=new_dup)
        if new_name != f.original_name:
            plan.append(PlanEntry(file=f, new_name=new_name))
    return plan


def incorporate_class_changes(plan: List[PlanEntry], files: List[FileInfo]) -> None:
    # 确保 class 变化也进入 plan（在 class mapping 后）
    existing_files_in_plan = {p.file for p in plan}
    for f in files:
        proposed = f.build_name()
        if proposed != f.original_name and f not in existing_files_in_plan:
            plan.append(PlanEntry(file=f, new_name=proposed))


def ensure_unique_targets(plan: List[PlanEntry]) -> None:
    # 若存在两个不同源文件指向同名目标，需要中间临时名过渡
    name_to_entries: Dict[str, List[PlanEntry]] = {}
    for e in plan:
        name_to_entries.setdefault(e.new_name, []).append(e)
    collisions = {k: v for k, v in name_to_entries.items() if len(v) > 1}
    if not collisions:
        return
    # 处理方式: 对所有计划重命名先加临时后缀 .__tmpN__ 再第二轮改为目标
    # 在 execute_rename 中实现两阶段。这里只是标记；不改变 new_name。
    return


def execute_plan(plan: List[PlanEntry], apply: bool, verbose: bool = False) -> None:
    if not apply:
        return
    # 两阶段避免覆盖
    # 阶段1: 临时名
    temp_paths: List[Tuple[Path, Path]] = []
    used_temp: set[str] = set()
    for idx, entry in enumerate(plan):
        src = entry.file.path
        temp_name = f".__tmp__{idx}__{entry.new_name}"
        while temp_name in used_temp:
            temp_name = f".__tmp__{idx}_{len(used_temp)}__{entry.new_name}"
        used_temp.add(temp_name)
        tmp_path = src.with_name(temp_name)
        if verbose:
            print(f"TEMP {src.name} -> {tmp_path.name}")
        src.rename(tmp_path)
        temp_paths.append((tmp_path, src.with_name(entry.new_name)))
    # 阶段2: 目标名
    for tmp_path, final_path in temp_paths:
        if verbose:
            print(f"FINAL {tmp_path.name} -> {final_path.name}")
        tmp_path.rename(final_path)


def generate_report(report: Report, verbose: bool = False) -> None:
    print("==== SortCheck Report ====")
    print(f"Total files in dir  : {report.total_files}")
    print(f"Parsed target files  : {report.parsed_files}")
    if report.unparsable:
        print(f"Unmatched filenames  : {len(report.unparsable)}")
        if verbose:
            for n in report.unparsable:
                print(f"  - {n}")
    cr = report.class_result
    print(f"Class had gap        : {cr.had_gap}")
    if cr.had_gap:
        print(f"Class mapping        : {cr.old_to_new}")
    if report.duplicate_conflicts:
        print("Duplicate conflicts (need manual check):")
        for d in report.duplicate_conflicts:
            print(f"  class {d.cls} dup {d.duplicate_value} -> {d.file_names}")
    if report.duplicate_reindex:
        print("Duplicate reindex mappings:")
        for r in report.duplicate_reindex:
            if any(old != new for old, new in r.mapping.items()):
                print(f"  class {r.cls}: {r.mapping}")
    if report.rename_plan:
        print("Planned renames:")
        for e in report.rename_plan:
            print(f"  {e.file.original_name} -> {e.new_name}")
    else:
        print("No renames necessary.")

# ---------------- CLI -----------------

def process_one_directory(directory: Path, apply: bool, verbose: bool, interactive_dup: bool) -> int:
    if not directory.is_dir():
        print(f"Error: directory not found: {directory}", file=sys.stderr)
        return 2

    files, unparsable = load_files(directory)
    class_result = build_class_mapping(files)
    # 先保存原始对象用于后续 rename plan 判断差异
    apply_class_mapping(files, class_result)

    dup_conflicts, dup_reindexes = analyze_duplicates(files)

    if interactive_dup and dup_conflicts:
        # 进入交互处理阶段
        interactive_resolve_duplicate_conflicts(dup_conflicts, files)
        # 交互修改后重新分析
        dup_conflicts, dup_reindexes = analyze_duplicates(files)

    rename_plan = build_rename_plan(files, dup_reindexes)
    incorporate_class_changes(rename_plan, files)
    ensure_unique_targets(rename_plan)

    if not rename_plan and not dup_conflicts and not class_result.had_gap:
        if apply:
            print("[INFO] 没有需要重命名的文件：class 与 duplicate 均已连续且无冲突。")

    report = Report(
        total_files=len(list(directory.iterdir())),
        parsed_files=len(files),
        unparsable=unparsable,
        class_result=class_result,
        duplicate_conflicts=dup_conflicts,
        duplicate_reindex=dup_reindexes,
        rename_plan=rename_plan,
    )

    generate_report(report, verbose=verbose)

    if dup_conflicts and apply:
        print("Abort: duplicate conflicts present; resolve manually before applying.", file=sys.stderr)
        return 3

    if apply:
        print(f"[DEBUG] 即将执行重命名，计划条目: {len(rename_plan)}")
        if not rename_plan:
            print("[WARN] 没有重命名计划，可能由于：\n  - 文件已符合规则\n  - 仅存在 duplicate 冲突但未交互解决 (未应用)\n  - 规则匹配失败或目录为空")

    execute_plan(rename_plan, apply=apply, verbose=verbose)
    if apply:
        print("Renaming complete.")
    else:
        print("Dry-run (use --apply to perform changes).")
    return 0


def main(argv: Optional[Iterable[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Check and fix class/duplicate indices in image filenames.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-d', '--dir', type=str, help='Target directory containing images')
    group.add_argument('--class-all', dest='class_all', type=str, help="Root directory that contains many subfolders; recursively process all 'pic' subdirectories")
    parser.add_argument('--apply', action='store_true', help='Apply changes (otherwise dry-run)')
    parser.add_argument('--verbose', action='store_true', help='Verbose output')
    parser.add_argument('--interactive-dup', action='store_true', help='交互式处理 duplicate 冲突')
    args = parser.parse_args(list(argv) if argv is not None else None)

    if args.dir:
        directory = Path(args.dir)
        return process_one_directory(directory, apply=args.apply, verbose=args.verbose, interactive_dup=args.interactive_dup)

    # class_all 模式: 递归查找所有名为 'pic' 的目录并分别处理
    root = Path(args.class_all)
    if not root.is_dir():
        print(f"Error: class_all root not found: {root}", file=sys.stderr)
        return 2
    pic_dirs = sorted({p for p in root.rglob('pic') if p.is_dir() and p.name.lower() == 'pic'})
    if not pic_dirs:
        print(f"[WARN] 在 {root} 下未发现任何名为 'pic' 的子目录。")
        return 0
    print(f"[INFO] 在 {root} 下发现 {len(pic_dirs)} 个 'pic' 目录，将逐一处理。")
    total = len(pic_dirs)
    failures = 0
    nonzero_codes: List[int] = []
    for idx, pic in enumerate(pic_dirs, start=1):
        print("\n" + "=" * 12 + f" [{idx}/{total}] Processing 'pic' dir: {pic} " + "=" * 12)
        code = process_one_directory(pic, apply=args.apply, verbose=args.verbose, interactive_dup=args.interactive_dup)
        if code != 0:
            failures += 1
            nonzero_codes.append(code)
    print("\n[SUMMARY] 'pic' 目录处理完成: total=", total, " failures=", failures)
    return nonzero_codes[-1] if nonzero_codes else 0

if __name__ == '__main__':
    raise SystemExit(main())
