# Part 3 语法进阶部分

## 1. 课件5：流程控制

程序执行的三种基本结构：  

- 顺序结构（Sequential Structure）  
    代码按顺序从上到下执行。
- 选择结构（Selection Structure）  
    或称为分支结构  
    根据条件判断执行不同的代码块。
- 循环结构（Loop Structure）  
    根据条件重复执行代码块。

### 1.1. 顺序结构

顺序结构是程序中最基本的执行方式，代码按书写顺序逐行执行。

### 1.2. 选择结构

分支结构  

根据条件成立预购，决定执行哪个代码块。  

- 单分支结构（if语句）  
- 双分支结构（if-else语句）  
- 条件表达式（三元表达式）  
- 多分支结构（if-elif-else语句）
- 嵌套分支结构  

#### 1.2.1. 补充

random模块  
常配合选择结构使用，实现随机决策。  

常用函数：

- randint(a, b)：返回[a, b]范围内的随机整数。  
- choice(seq)：从非空序列seq中随机选择一个元素。  
- shuffle(seq)：将序列seq随机打乱。
- sample(population, k)：从总体population中随机选择k个独立元素，返回列表。  

### 1.3. 循环结构

循环结构用于重复执行代码块，直到满足特定条件。  

两种基本语句：  

- while循环  
    根据条件表达式的真假决定是否继续循环。  
    适用于循环次数不确定的情况。  
- for循环  
    遍历序列（如列表、字符串、字典等）中的每个元素。  
    适用于已知循环次数的情况。  
- 循环中的else子句  
    python特色  
    如果循环正常结束（非break跳出），则执行else块。  
- range()函数  
    生成整数序列，常用于for循环。  
    支持start, stop, step参数。  
    语法：range(start, stop[, step])  
    start默认为0，step默认为1  
    仅stop不可以缺省  

#### 1.3.1. 循环控制与跳转语句

- break语句  
    立即终止循环，跳出循环体。  
- continue语句  
    跳过当前循环迭代，进入下一次循环。
- pass语句  
    占位符语句，不执行任何操作。  
    用于需要语法上有代码但逻辑上不需要执行任何操作的场景。  

#### 1.3.2. 嵌套循环与优化

- 嵌套循环  
    在一个循环体内再包含另一个循环。  
    注意控制好循环变量，避免混淆。  
- 循环优化技巧  
    尽量减少循环内部不必要的计算量  

## 2. 课件6：列表与元组

python中两种最重要的线性数据结构  

- 列表（List）  
    可变序列，支持增删改查操作。  
    使用方括号[]定义，元素可为任意类型。  
- 元组（Tuple）  
    不可变序列，一旦创建无法修改。  
    使用圆括号()定义，适用于存储不可变数据。  

以及他们的共有重要操作 **切片（Slicing）**  

### 2.1. 数据结构和序列基础

数据结构：组织和存储数据的方式  
程序逻辑通过数据机构执行CRUD（增删改查）操作。  

序列：有序的数据集合，支持索引和切片操作。  
Python中包含列表、元组、字典、字符串等  

- 有序序列：列表、元组、字符串  
    支持双向索引  
    正向从0开始，反向（指从尾开始）从-1开始  
- 无序序列：字典、集合  

- 可变性：  
    可变序列：列表、字典、集合  
    不可变序列：元组、字符串  

共性方法：  

- len()：获取序列长度。  
- min()：获取序列中的最小值。
- max()：获取序列中的最大值。  
- sum()：计算数值序列的总和。
- in运算符：检查元素是否在序列中存在。
- sorted()函数：返回序列的排序版本，不修改原序列。  
- reversed()函数：返回序列的反转版本，不修改原序列。  
- enumerate()函数：同时获取元素索引和值，常用于循环遍历。  

### 2.2. 列表（List）

列表是包含在`[]`中的有序元素集合，支持动态修改。  
Python中列表支持存储不同类型的元素。  

内存本质：列表对象保存对元素对象的引用。  

基本操作：  

- C：  
    - `[]`：创建空列表。  
    - `[elem1, elem2, ...]`：创建包含初始元素的列表。
    - `list(iterable)`：将可迭代对象转换为列表。
    - `append(elem)`：在列表末尾添加元素。
    - `insert(index, elem)`：在指定索引位置插入元素。  
        正向时，`index`范围为0到len(list)。  
        支持负索引。  
    - `extend(iterable)`：将可迭代对象的元素添加到列表末尾。  
- R：  
    - 通过索引访问元素，如`list[index]`。  
    - `index(elem)`：返回元素首次出现的索引。  
    - `count(elem)`：返回元素在列表中出现的次数。  
    - `in`运算符：检查元素是否在列表中存在。  
- U:  
    - 通过索引修改元素，如`list[index] = new_value`。  
    - `sort()`：对列表进行原地排序。  
        原地指修改当前列表，不返回新列表。  
    - `reverse()`：反转列表元素顺序。  
- D:  
    - `del`语句：删除指定索引的元素。  
    - `pop([index])`：移除并返回指定索引的元素，默认移除最后一个。  
    - `remove(elem)`：移除列表中首次出现的指定元素。  
    - `clear()`：清空列表所有元素。  
    - 易错环节：循环中删除列表元素，列表长度和索引会发生唯一，导致漏删  
        正确做法：遍历原列表的副本，或者从后向前删除。  

#### 2.2.1. 列表推导式

列表推导式是一种简洁的创建和操作列表的方式。  
利用已有列表创建新列表。

语法：  
`[表达式 for 变量 in 可迭代对象 if 条件]`  

注意，以上结构也可以嵌套使用，形成多重循环或条件。  

### 2.3. 元组（Tuple）

轻量的只读列表。  
使用`()`定义，一旦创建不可修改。  
*实际上指的是这里的引用不能再指向其他对象，也不能添加或删除元素*  

创建注意事项：

- 单元素元组：需要在元素后加逗号，如`(elem,)`，否则被视为普通括号表达式。  
- 空元组：使用`()`创建。

优势：  

- 不可变性：适用于存储不可修改的数据，提高数据安全性。
- 性能优势：由于不可变，元组在内存中占用更少空间，访问速度更快。
- 可作为字典键：由于不可变，元组可以用作字典的键，而列表不行。

深度理解不可变性：  
指的是引用不能更改，但是如果引用指向的元素本身是可变的，那么可以修改该元素的内容。  

#### 2.3.1. 生成器表达式

生成器表达式是一种简洁的创建生成器的方式。  

语法：  
`(表达式 for 变量 in 可迭代对象 if 条件)`  
返回生成器对象，按需计算元素。  
惰性求值，节省内存。  
适用场景：处理大数据集，避免一次性加载所有数据。  

#### 2.3.2. 序列解包

可以将序列中的值一次性存储到多个变量中  

示例：  

- `x, y = 1, 2`：将元组(1, 2)解包到变量x和y中。  
- 通配符`*`：用于捕获多余元素，形成列表。  
    - `a, *b, c = [1, 2, 3, 4, 5]`：a=1, b=[2, 3, 4], c=5  
- 交换变量值：`a, b = b, a`，无需临时变量。

### 2.4. 切片操作

序列的高级截取  

语法：  
`L[start:stop:step]`  

核心特性：  
浅拷贝（Shallow Copy）：切片返回的是原序列的浅拷贝，修改切片不会影响原序列。  

- start：起始索引，默认为0。
- stop：结束索引（不包含），默认为序列长度。
- step：步长，默认为1。可以为负数，实现反向切片。  

支持省略参数：  

- `L[:]`：复制整个序列。
- `L[start:]`：从start到末尾。
- `L[:stop]`：从开头到stop（不包含）。
- `L[::step]`：整个序列，按step步长取值。

原地修改：  
可以通过切片实现对序列的原地修改。  
例如：`L[start:stop] = iterable`，将指定范围内的元素替换为新的可迭代对象的元素。  
注意：如果步长不为1，替换的元素数量必须与切片长度相同。  

## 3. 课件7：字典和集合

两种重要的非线性数据结构：  

- 字典（Dictionary）  
    无序的键值对集合，支持快速查找和修改。  
    使用花括号{}定义，键必须是不可变类型。  
- 集合（Set）  
    无序的不重复元素集合，支持数学集合操作。  
    使用花括号{}或set()函数定义。  

### 3.1. 字典（Dictionary）

映射（Mapping）类型  
存储键值对（key-value pairs）  
通过键访问对应的值，支持快速查找和修改。  

核心特性：  
键（Key）唯一且不可变  
值（Value）可以是任意类型  
字典通常被认为是无序的  

#### 3.1.1. 操作

创建字典：  

- `{}`：创建空字典。  
- `{'key1': value1, 'key2': value2, ...}`：创建包含初始键值对的字典。  
- `dict(iterable)`：将可迭代对象转换为字典。  
    可以通过包含元组的列表或者`zip()`对象创建字典。  
- `dict.fromkeys(keys, value)`：使用指定的键列表创建字典，所有键对应相同的初始值。  

CRUD：  

- C/U：  
    - `dict[key] = value`：添加或更新键值对。  
    - `setdefault(key, default)`：如果键不存在，添加键并设置默认值。  
- R:  
    - `dict[key]`：通过键访问对应的值。  
        键不存在时抛出KeyError异常。  
    - `get(key, default)`：通过键访问值，键不存在时返回默认值。  
        更安全  
    - `keys()`：返回字典的所有键。  
    - `values()`：返回字典的所有值。  
    - `items()`：返回字典的所有键值对。
- D:  
    - `del dict[key]`：删除指定键的键值对。  
    - `pop(key, default)`：删除并返回指定键的值，键不存在时返回默认值。  
    - `popitem()`：删除并返回一个任意键值对（Python 3.7+为最后一个）。  
    - `clear()`：清空字典所有键值对。

### 3.2. 集合（Set）

无序、不重复的元素集合  

核心特性：  

- 元素必须是不可变的  
- 自动去重：定义时重复元素会被自动移除。  

#### 3.2.1. 操作

创建集合：  

- `{elem1, elem2, ...}`：创建包含初始元素的集合。  
    特别注意：使用空花括号`{}`会创建一个空字典，而不是集合。  
- `set()`：创建空集合。
- `set(iterable)`：将可迭代对象转换为集合。
- `frozenset(iterable)`：创建不可变集合。

CRUD：  

- C:  
    - `add(elem)`：向集合添加元素。  
    - `update(iterable)`：将可迭代对象的元素添加到集合中。
- R:  
    - 通过`in`运算符检查元素是否在集合中存在。
    - `len()`：获取集合中元素的数量。
- U:  
    集合本身不支持更新操作，但可以通过添加和删除元素来间接实现更新。  
- D:  
    - `remove(elem)`：从集合中移除指定元素，元素不存在时抛出KeyError异常。
    - `discard(elem)`：从集合中移除指定元素，元素不存在时不抛出异常。
    - `pop()`：随机移除并返回一个元素，集合为空时抛出KeyError异常。

数学运算：  

- 并集（Union）：`A | B`或`A.union(B)`，返回包含A和B所有元素的新集合。  
- 交集（Intersection）：`A & B`或`A.intersection(B)`，返回同时存在于A和B的元素的新集合。  
- 差集（Difference）：`A - B`或`A.difference(B)`，返回存在于A但不在B中的元素的新集合。  
- 对称差集（Symmetric Difference）：`A ^ B`或`A.symmetric_difference(B)`，返回存在于A或B但不同时存在于两者的元素的新集合。  
- 子集和超集：`A <= B`检查A是否为B的子集，`A >= B`检查A是否为B的超集。  

### 3.3. 性能对比

字典/集合：  
基于哈希表实现，查找、插入和删除操作平均时间复杂度为O(1)。  
不随着数据量增加而显著变慢。  
占用空间更大。  

列表/元组：  
线性结构  
索引查找快，但按值查找慢，平均时间复杂度为O(n)。  
占用空间小  

建议：  
处理大规模数据的成员检测或查找时  
最好将列表结构重构为字典结构  
显著提升性能。  
